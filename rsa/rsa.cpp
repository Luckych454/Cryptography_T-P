//
// Created by 406 on 2019/11/15.
//
#include <iostream>
#include <string>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <bitset>
#include<time.h>
using namespace std;
/*
 * 我决定了，用c++写
 * 好的
 * 快写
 *
 * 实现2048RSA加密并给出解密函数验证
 * 要求：
 * p 和 q 是两个1024的安全素数，根据学号最后一位的数字选择
 * p = 74829638746533240988779487685519857207853614853369269125737224926836190844584386477252351678694220847326413610447912126732461551667746605631104998257474529620520790296706975377558703885069067389851079532628142311782993846028093717798601985881211947182951877707743021688050533047297428267547207193214872407179
 * q = 74829638746533240988779487685519857207853614853369269125737224926836190844584386477252351678694220847326413610447912126732461551667746605631104998257474529620520790296706975377558703885069067389851079532628142311782993846028093717798601985881211947182951877707743021688050533047297428267547207193214872407179
 * 密钥是学号的下一个素数：17340031
 * 公钥就是生成的啦
 * 明文是中山大学的英文 (Sun Yat-sen University) 进行OAEP填充到2048位
 * 填充是使用两个Hash函数为实验4实现的SHA-1的扩展 hash六次，前面补0 到1024位
 *
 * p 和 q 一开始肯定是字符串了，然后呢，怎么变成一个大整数
 *
 */

typedef bitset<8> byte;
typedef bitset<32> word;
typedef bitset<2048> msg;

struct Wint:vector<int>{
    //用标准库vector做基类，完美解决位数问题，同时更易于实现
    //将低精度转高精度的初始化，可以自动被编译器调用
    //因此无需单独写高精度数和低精度数的运算函数，十分方便
    Wint(int n=0)//默认初始化为0，但0的保存形式为空
    {
        push_back(n);
        check();
    }
    Wint& check()//在各类运算中经常用到的进位小函数，不妨内置
    {
        while(!empty()&&!back()) pop_back();//去除最高位可能存在的0
        if(empty())return *this;
        for(int i=1; i<size(); ++i)
        {
            (*this)[i]+=(*this)[i-1]/10;
            (*this)[i-1]%=10;
        }
        while(back()>=10)
        {
            push_back(back()/10);
            (*this)[size()-2]%=10;
        }
        return *this;//为使用方便，将进位后的自身返回引用
    }
};
Wint string2Wint(string s){
    Wint n;
    for(int i=s.size()-1; i>=0; --i)n.push_back(s[i]-'0');
    return n;
}
class RSA{
private:
    msg _p,_q,_r;
    msg _n,_phin;
    // a 和 b 可以表示为大整数形式
public:
    RSA(){
        // 怎么处理p和q这两个字符串的大整数呢, 将他们变为1024的比特串
        // 先用vector入，然后变成msg
        // 其实主要是因为想要计算。。。 n phin 和 a 的逆

    }
    // 对一个明文进行进行OAEP
    msg encodeOAEP(string str){

    }
    // 对密文进行OAEP
    string decodeOAEP(msg decode){

    }
    // RSA 公钥加密
    msg RSAencode(msg){

    }
    // RSA 私钥解密
    msg RSAdecode(){

    }
    // 在RSA中实现的大整数运算：pow(multiply,mod),inverse
};
int main(){
    // 1024bit的p和q
    string p = "74829638746533240988779487685519857207853614853369269125737224926836190844584386477252351678694220847326413610447912126732461551667746605631104998257474529620520790296706975377558703885069067389851079532628142311782993846028093717798601985881211947182951877707743021688050533047297428267547207193214872407179";
    string q = "74829638746533240988779487685519857207853614853369269125737224926836190844584386477252351678694220847326413610447912126732461551667746605631104998257474529620520790296706975377558703885069067389851079532628142311782993846028093717798601985881211947182951877707743021688050533047297428267547207193214872407179";

}
